---
phase: 02-session-management
plan: '02'
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/NotePanel.tsx
  - src/components/TagInput.tsx
  - src/hooks/useSessionNotes.ts
autonomous: true
requirements:
  - NOTE-01
  - NOTE-02
  - NOTE-03
  - NOTE-04
  - NOTE-05

must_haves:
  truths:
    - "Note panel only visible during Focus mode"
    - "Notes autosave with 500ms debounce while typing"
    - "Tag input supports chip creation via Enter, removal via X and Backspace"
    - "Tag counter shows X/10 tags used"
    - "Autocomplete suggestions appear from previously used tags"
  artifacts:
    - path: "src/components/NotePanel.tsx"
      provides: "Collapsible note input with autosave status"
      contains: "TextArea"
    - path: "src/components/TagInput.tsx"
      provides: "Chip-based tag input with autocomplete"
      contains: "Chip"
    - path: "src/hooks/useSessionNotes.ts"
      provides: "Note state management with 500ms debounced autosave"
      contains: "useDebounce"
  key_links:
    - from: "src/components/NotePanel.tsx"
      to: "src/hooks/useSessionNotes.ts"
      via: "useSessionNotes hook"
      pattern: "useSessionNotes"
---

<objective>
Create NotePanel and TagInput components with 500ms debounced autosave.
</objective>

<execution_context>
@/Users/michaelrobert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelrobert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/02-session-management/02-CONTEXT.md
@.planning/phases/02-session-management/02-RESEARCH.md
@src/types/session.ts
@src/components/TimerDisplay.tsx
</context>

<tasks>

<task type="auto">
  <name>Create useSessionNotes hook with 500ms debounce</name>
  <files>src/hooks/useSessionNotes.ts</files>
  <action>
Create a hook that manages note state with debounced autosave:

```typescript
import { useState, useCallback, useRef, useEffect } from 'react'
import { SessionNoteState } from '../types/session'

// Custom debounce hook (no dependency needed)
function useDebounce<T extends (...args: unknown[]) => unknown>(
  callback: T,
  delay: number
): T {
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)

  const debouncedCallback = useCallback(
    (...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
      timeoutRef.current = setTimeout(() => {
        callback(...args)
      }, delay)
    },
    [callback, delay]
  ) as T

  return debouncedCallback
}

const MAX_NOTE_LENGTH = 2000

export function useSessionNotes(onSave: (note: string, tags: string[]) => void) {
  const [noteText, setNoteText] = useState('')
  const [tags, setTags] = useState<string[]>([])
  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle')
  const [lastSaved, setLastSaved] = useState<number | null>(null)

  // Debounced save function - 500ms delay
  const debouncedSave = useDebounce((text: string, currentTags: string[]) => {
    setSaveStatus('saving')
    onSave(text, currentTags)
    setTimeout(() => {
      setSaveStatus('saved')
      setLastSaved(Date.now())
    }, 100)
  }, 500)

  const handleNoteChange = useCallback((text: string) => {
    if (text.length <= MAX_NOTE_LENGTH) {
      setNoteText(text)
      setSaveStatus('saving')
      debouncedSave(text, tags)
    }
  }, [tags, debouncedSave])

  const handleTagsChange = useCallback((newTags: string[]) => {
    setTags(newTags)
    setSaveStatus('saving')
    debouncedSave(noteText, newTags)
  }, [noteText, debouncedSave])

  const resetNotes = useCallback(() => {
    setNoteText('')
    setTags([])
    setSaveStatus('idle')
    setLastSaved(null)
  }, [])

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [])

  return {
    noteText,
    tags,
    saveStatus,
    lastSaved,
    maxNoteLength: MAX_NOTE_LENGTH,
    handleNoteChange,
    handleTagsChange,
    resetNotes,
  }
}
```
  </action>
  <verify>File exists, exports useSessionNotes hook, no build errors</verify>
  <done>useSessionNotes provides: noteText, tags, saveStatus, lastSaved, handleNoteChange, handleTagsChange, resetNotes</done>
</task>

<task type="auto">
  <name>Create NotePanel component</name>
  <files>src/components/NotePanel.tsx</files>
  <action>
Create collapsible note panel using styled-components:

```typescript
import React from 'react'
import styled from 'styled-components'

const Panel = styled.div<{ $isVisible: boolean }>`
  display: ${props => props.$isVisible ? 'block' : 'none'};
  margin-top: 1rem;
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  background: #fafafa;
`

const TextArea = styled.textarea`
  width: 100%;
  min-height: 120px;
  padding: 0.75rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-family: inherit;
  font-size: 0.9rem;
  resize: vertical;
  box-sizing: border-box;

  &:focus {
    outline: none;
    border-color: #e74c3c;
  }
`

const StatusRow = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 0.5rem;
  font-size: 0.8rem;
  color: #666;
`

const SaveStatus = styled.span<{ $saving: boolean }>`
  color: ${props => props.$saving ? '#e67e22' : '#27ae60'};
`

interface NotePanelProps {
  isVisible: boolean
  noteText: string
  onNoteChange: (text: string) => void
  saveStatus: 'idle' | 'saving' | 'saved'
  lastSaved: number | null
  maxLength: number
}

export default function NotePanel({
  isVisible,
  noteText,
  onNoteChange,
  saveStatus,
  lastSaved,
  maxLength,
}: NotePanelProps) {
  const formatTime = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
  }

  return (
    <Panel $isVisible={isVisible}>
      <TextArea
        value={noteText}
        onChange={(e) => onNoteChange(e.target.value)}
        placeholder="Capture your thoughts..."
        maxLength={maxLength}
      />
      <StatusRow>
        <SaveStatus $saving={saveStatus === 'saving'}>
          {saveStatus === 'saving' ? 'Saving...' :
           saveStatus === 'saved' && lastSaved ? `Saved at ${formatTime(lastSaved)}` : ''}
        </SaveStatus>
        <span>{noteText.length}/{maxLength}</span>
      </StatusRow>
    </Panel>
  )
}
```
  </action>
  <verify>Component renders properly, styled-components used correctly</verify>
  <done>NotePanel shows textarea with placeholder "Capture your thoughts...", save status, and character count</done>
</task>

<task type="auto">
  <name>Create TagInput component with chip UI and autocomplete</name>
  <files>src/components/TagInput.tsx</files>
  <action>
Create tag input with chip interface:

```typescript
import React, { useState, useRef, useEffect } from 'react'
import styled from 'styled-components'

const TAG_REGEX = /^[a-zA-Z0-9-]{1,20}$/
const MAX_TAGS = 10

const Container = styled.div<{ $isVisible: boolean }>`
  display: ${props => props.$isVisible ? 'block' : 'none'};
  margin-top: 0.75rem;
`

const TagsContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
`

const Chip = styled.span`
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.25rem 0.5rem;
  background: #e74c3c;
  color: white;
  border-radius: 12px;
  font-size: 0.85rem;
`

const RemoveButton = styled.button`
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  padding: 0;
  font-size: 1rem;
  line-height: 1;
  opacity: 0.8;

  &:hover {
    opacity: 1;
  }
`

const Input = styled.input`
  width: 100%;
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.9rem;
  box-sizing: border-box;

  &:focus {
    outline: none;
    border-color: #e74c3c;
  }

  &:disabled {
    background: #f5f5f5;
    cursor: not-allowed;
  }
`

const SuggestionsList = styled.ul`
  position: absolute;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  list-style: none;
  padding: 0;
  margin: 0;
  width: calc(100% - 2rem);
  max-height: 150px;
  overflow-y: auto;
  z-index: 10;
`

const SuggestionItem = styled.li`
  padding: 0.5rem;
  cursor: pointer;

  &:hover {
    background: #f5f5f5;
  }
`

const Counter = styled.span`
  font-size: 0.8rem;
  color: #666;
  margin-top: 0.25rem;
  display: block;
`

interface TagInputProps {
  isVisible: boolean
  tags: string[]
  suggestions: string[]
  onTagsChange: (tags: string[]) => void
}

export default function TagInput({
  isVisible,
  tags,
  suggestions,
  onTagsChange,
}: TagInputProps) {
  const [input, setInput] = useState('')
  const [showSuggestions, setShowSuggestions] = useState(false)
  const inputRef = useRef<HTMLInputElement>(null)

  const filteredSuggestions = suggestions
    .filter(s => !tags.includes(s))
    .filter(s => s.toLowerCase().includes(input.toLowerCase()))
    .slice(0, 5)

  const addTag = (value: string) => {
    const tag = value.trim().toLowerCase()
    if (TAG_REGEX.test(tag) && tags.length < MAX_TAGS && !tags.includes(tag)) {
      onTagsChange([...tags, tag])
      setInput('')
      setShowSuggestions(false)
    }
  }

  const removeTag = (index: number) => {
    onTagsChange(tags.filter((_, i) => i !== index))
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      if (input) addTag(input)
    }
    if (e.key === 'Backspace' && !input && tags.length > 0) {
      removeTag(tags.length - 1)
    }
    if (e.key === 'Escape') {
      setShowSuggestions(false)
    }
  }

  return (
    <Container $isVisible={isVisible}>
      <TagsContainer>
        {tags.map((tag, i) => (
          <Chip key={i}>
            {tag}
            <RemoveButton onClick={() => removeTag(i)}>x</RemoveButton>
          </Chip>
        ))}
      </TagsContainer>
      <Input
        ref={inputRef}
        value={input}
        onChange={(e) => {
          setInput(e.target.value)
          setShowSuggestions(true)
        }}
        onKeyDown={handleKeyDown}
        onFocus={() => setShowSuggestions(true)}
        onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
        disabled={tags.length >= MAX_TAGS}
        placeholder={tags.length >= MAX_TAGS ? 'Max tags reached' : 'Add tag (press Enter)...'}
      />
      {input && showSuggestions && filteredSuggestions.length > 0 && (
        <SuggestionsList>
          {filteredSuggestions.map(s => (
            <SuggestionItem
              key={s}
              onClick={() => addTag(s)}
            >
              {s}
            </SuggestionItem>
          ))}
        </SuggestionsList>
      )}
      <Counter>{tags.length}/10 tags used</Counter>
    </Container>
  )
}
```

Note: Per locked decisions, tags use red color (focus mode color). The container uses position: relative in the parent for proper suggestions positioning.
  </action>
  <verify>Component renders, chip creation/removal works, autocomplete functions</verify>
  <done>TagInput shows chips with X removal, accepts input via Enter, shows autocomplete suggestions, displays counter "X/10 tags used"</done>
</task>

</tasks>

<verification>
- [ ] useSessionNotes hook with 500ms debounce implemented
- [ ] NotePanel displays collapsible textarea with "Capture your thoughts..." placeholder
- [ ] NotePanel shows save status and character count
- [ ] TagInput renders chips with X button removal
- [ ] TagInput supports Enter to create tags and Backspace to remove last tag
- [ ] TagInput shows autocomplete suggestions from previous tags
- [ ] TagInput shows "X/10 tags used" counter
- [ ] Both components respect isVisible prop (visible only during Focus mode)
</verification>

<success_criteria>
Note panel and tag input UI components created with 500ms debounced autosave. Tags use chip interface with both removal methods. Counter shows "X/10 tags used".
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management/02-02-SUMMARY.md`
</output>
