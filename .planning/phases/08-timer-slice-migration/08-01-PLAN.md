---
phase: 08-timer-slice-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/store.ts
  - src/hooks/useTimer.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - Timer state managed by Redux instead of useReducer
    - Timer actions work identically to current useReducer (start, pause, resume, tick, skip, reset)
    - Timer persists to IndexedDB with 2-second debouncing while running
    - Timer accuracy preserved using timestamps (not tick counting)
    - Background tab visibility changes recalculate timer correctly
    - useTimer hook API remains unchanged (backward compatible)
  artifacts:
    - path: src/features/timer/timerSlice.ts
      provides: Redux slice with timer actions and reducer
      exports: [start, pause, resume, reset, tick, skip, setMode, setCustomDurations, loadState]
    - path: src/features/timer/timerMiddleware.ts
      provides: Custom persistence middleware for IndexedDB sync
      contains: Debounced save (2000ms), immediate save on pause/stop
    - path: src/app/store.ts
      provides: Updated Redux store with timer slice and middleware
      contains: timer reducer, timerPersistenceMiddleware
    - path: src/hooks/useTimer.ts
      provides: Compatibility layer using Redux internally
      exports: Same API as before (state, start, pause, resume, reset, skip, setMode, autoStart, setAutoStart, setCustomDurations)
  key_links:
    - from: src/hooks/useTimer.ts
      to: src/features/timer/timerSlice.ts
      via: useAppDispatch and useAppSelector
      pattern: dispatch(start|pause|resume|reset|tick|skip|setMode|setCustomDurations|loadState)
    - from: src/features/timer/timerMiddleware.ts
      to: src/services/persistence.ts
      via: saveTimerState, saveTimerStateImmediate functions
      pattern: saveTimerState.*Debounced|saveTimerStateImmediate
    - from: src/app/store.ts
      to: src/features/timer/
      via: reducer and middleware configuration
      pattern: timerReducer.*timerPersistenceMiddleware
---

<objective>
Migrate timer state from useReducer to Redux Toolkit with custom persistence middleware while maintaining existing hook API.

Purpose: Centralize timer state in Redux for better DevTools, testing, and future feature development while preserving timer accuracy and IndexedDB persistence.

Output: Timer slice in src/features/timer/, updated store, and refactored useTimer hook with unchanged API.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-redux-foundation/07-01-SUMMARY.md
@.planning/phases/08-timer-slice-migration/08-RESEARCH.md
@src/app/store.ts
@src/app/hooks.ts
@src/hooks/useTimer.ts
@src/types/timer.ts
@src/constants/timer.ts
@src/services/persistence.ts
@src/services/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timerSlice.ts with Redux actions</name>
  <files>src/features/timer/timerSlice.ts</files>
  <action>
Create src/features/timer/ directory and timerSlice.ts file using createSlice from Redux Toolkit. Define initial state matching current TimerState type. Implement all reducer actions:
- start: Set isRunning=true, startTime=Date.now(), pausedTimeRemaining=null
- pause: Set isRunning=false, pausedTimeRemaining=timeRemaining, startTime=null
- resume: Set isRunning=true, startTime=Date.now()
- reset: Set timeRemaining=duration, isRunning=false, clear timestamps
- tick: Calculate timeRemaining from startTime timestamp (not tick count)
- skip: Determine next mode (focus/shortBreak/longBreak), handle session count
- setMode: Switch mode and reset timer
- setCustomDurations: Update duration for current mode
- loadState: Replace state with loaded data

Use existing types from src/types/timer.ts and constants from src/constants/timer.ts. Export all actions and the reducer.
  </action>
  <verify>
Verify: TypeScript compiles without errors. File exports all required actions: start, pause, resume, reset, tick, skip, setMode, setCustomDurations, loadState.
  </verify>
  <done>Timer slice created with all required actions and proper TypeScript types matching existing TimerState interface.</done>
</task>

<task type="auto">
  <name>Task 2: Create timerPersistenceMiddleware.ts</name>
  <files>src/features/timer/timerMiddleware.ts</files>
  <action>
Create timerPersistenceMiddleware.ts in src/features/timer/ directory. Implement custom middleware that:
- Intercepts actions with type starting with 'timer/'
- Debounces saves to IndexedDB with 2000ms delay while timer is running
- Saves immediately when timer is paused or stopped
- Uses existing saveTimerState (debounced) and saveTimerStateImmediate from src/services/persistence.ts
- Clears pending timeout before setting new one to avoid overlapping saves
- Uses setTimeout reference outside function to maintain across dispatches

Import RootState type from src/app/store.ts for proper typing.
  </action>
  <verify>
Verify: TypeScript compiles without errors. Middleware properly typed with Middleware from @reduxjs/toolkit.
  </verify>
  <done>Custom persistence middleware created with 2000ms debouncing while running and immediate saves on pause/stop.</done>
</task>

<task type="auto">
  <name>Task 3: Update store.ts with timer slice and middleware</name>
  <files>src/app/store.ts</files>
  <action>
Update src/app/store.ts to:
- Import timerReducer from ../features/timer/timerSlice
- Import timerPersistenceMiddleware from ../features/timer/timerMiddleware
- Add timer: timerReducer to the reducer configuration
- Add middleware to use getDefaultMiddleware and prepend timerPersistenceMiddleware
- Configure serializableCheck to ignore timer.startTime path (timestamps are numbers, not Date objects, but this silences the warning)

Keep existing HMR support. Update RootState type if needed (should auto-infer from reducer).
  </action>
  <verify>
Verify: TypeScript compiles without errors. Run `npm run build` or `npx tsc --noEmit` to verify store configuration.
  </verify>
  <done>Redux store updated with timer slice and persistence middleware.</done>
</task>

<task type="auto">
  <name>Task 4: Refactor useTimer.ts to use Redux</name>
  <files>src/hooks/useTimer.ts</files>
  <action>
Refactor src/hooks/useTimer.ts to use Redux instead of useReducer while maintaining the exact same API:
- Import useAppDispatch and useAppSelector from ../app/hooks
- Import timer slice actions from ../features/timer/timerSlice
- Replace useReducer with useAppSelector for state
- Replace useReducer dispatch with useAppDispatch
- Convert all dispatch({ type: 'ACTION' }) to dispatch(action())
- Keep initialization logic loading from IndexedDB (dispatch loadState)
- Keep tick interval logic (setInterval calling dispatch(tick()))
- Add visibilitychange listener to recalculate timer when tab becomes visible
- Keep session completion detection and notification logic
- Keep notification permission request on first interaction
- Maintain same return object shape: { state, start, pause, resume, reset, skip, setMode, autoStart, setAutoStart, setCustomDurations }

The external API must remain identical - no consumers should need to change.
  </action>
  <verify>
Verify: TypeScript compiles without errors. Run app and verify timer works - start, pause, resume, skip all function correctly. Use Redux DevTools to confirm actions dispatch properly.
  </verify>
  <done>useTimer hook refactored to use Redux internally with unchanged external API.</done>
</task>

<task type="auto">
  <name>Task 5: Test timer accuracy and persistence</name>
  <files></files>
  <action>
Test the migrated timer to verify:
1. Timer accuracy: Start timer, wait 10 seconds, verify displayed time is accurate (not drifted)
2. Background tab handling: Start timer, switch to another tab for 5 seconds, return, verify timer shows correct elapsed time
3. Persistence: Start timer, pause, refresh page, verify timer resumes from paused state
4. Session completion: Let timer run to completion, verify it auto-advances to next mode (focus -> break)
5. Redux DevTools: Open Redux DevTools, verify timer actions appear in action log

Use browser console to verify no errors. Check IndexedDB in DevTools Application tab to confirm state saves.
  </action>
  <verify>
Verify: Manual testing confirms all timer operations work correctly with no regression from previous useReducer implementation.
  </verify>
  <done>Timer accuracy preserved and persistence working correctly after migration.</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles without errors (`npx tsc --noEmit`)
- [ ] Build succeeds (`npm run build`)
- [ ] Timer starts, pauses, resumes, resets, skips correctly
- [ ] Timer display updates accurately (no drift)
- [ ] Timer persists across page refresh
- [ ] Redux DevTools shows timer actions
- [ ] No console errors during normal operation
</verification>

<success_criteria>
Phase complete when:
- Timer slice created with all required Redux actions (start, pause, resume, tick, skip, reset, setMode, setCustomDurations, loadState)
- Custom persistence middleware implements 2000ms debouncing while running
- useTimer hook API remains unchanged (backward compatible)
- Timer accuracy preserved using timestamps, not tick counting
- Background tab visibility changes handled correctly
- TypeScript compiles and build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/08-timer-slice-migration/{phase}-01-SUMMARY.md`
</output>
