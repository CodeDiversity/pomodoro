---
phase: 02-session-management
plan: '03'
type: execute
wave: 2
depends_on:
  - 02-01
  - 02-02
files_modified:
  - src/hooks/useSessionManager.ts
  - src/components/SessionSummary.tsx
  - src/App.tsx
  - src/hooks/useTimer.ts
autonomous: true
requirements:
  - SESS-01
  - SESS-02
  - SESS-03
  - SESS-04
  - SESS-05

must_haves:
  truths:
    - "Sessions save automatically when timer hits 0 in Focus mode"
    - "Sessions save when user clicks Skip in Focus mode"
    - "Periodic checkpoint saves every 5 minutes during Focus sessions"
    - "Manual save button available during Focus sessions"
    - "Incomplete sessions (reset/skip mid-session) are discarded"
    - "Summary modal shows after session ends with session details"
  artifacts:
    - path: "src/hooks/useSessionManager.ts"
      provides: "Session creation, save triggers, checkpoint logic"
      contains: "createSessionRecord"
    - path: "src/components/SessionSummary.tsx"
      provides: "Post-session summary modal"
      contains: "Modal"
    - path: "src/App.tsx"
      provides: "Integration of NotePanel, TagInput, SessionSummary"
      contains: "NotePanel"
  key_links:
    - from: "src/hooks/useTimer.ts"
      to: "src/hooks/useSessionManager.ts"
      via: "onSessionComplete callback"
      pattern: "onSessionComplete.*saveSession"
---

<objective>
Implement session save triggers and integrate note/tag components with timer.
</objective>

<execution_context>
@/Users/michaelrobert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelrobert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/02-session-management/02-CONTEXT.md
@.planning/phases/02-session-management/02-RESEARCH.md
@.planning/phases/02-session-management/02-01-PLAN.md
@.planning/phases/02-session-management/02-02-PLAN.md
@src/types/session.ts
@src/types/timer.ts
@src/hooks/useTimer.ts
</context>

<tasks>

<task type="auto">
  <name>Create useSessionManager hook</name>
  <files>src/hooks/useSessionManager.ts</files>
  <action>
Create session manager hook for handling session creation and save triggers:

```typescript
import { useCallback, useRef, useEffect } from 'react'
import { SessionRecord, SessionNoteState } from '../types/session'
import { saveSession, saveTag } from '../services/sessionStore'
import { TimerMode } from '../types/timer'

const CHECKPOINT_INTERVAL_MS = 5 * 60 * 1000 // 5 minutes

interface SessionManagerParams {
  mode: TimerMode
  isRunning: boolean
  duration: number
  startTime: number | null
  noteState: SessionNoteState
}

interface SessionManagerActions {
  onSessionComplete: () => void
  onSessionSkip: () => void
  onSessionReset: () => void
}

export function useSessionManager(
  params: SessionManagerParams,
  actions: SessionManagerActions
) {
  const sessionStartRef = useRef<number | null>(null)
  const lastCheckpointRef = useRef<number>(0)
  const hasCompletedRef = useRef(false)

  // Format duration as MM:SS
  const formatDuration = (secs: number): string => {
    const mins = Math.floor(secs / 60)
    const remainingSecs = secs % 60
    return `${mins.toString().padStart(2, '0')}:${remainingSecs.toString().padStart(2, '0')}`
  }

  // Create a complete session record
  const createSessionRecord = useCallback((completed: boolean): SessionRecord => {
    const now = Date.now()
    const startTime = sessionStartRef.current || now
    const actualDuration = params.duration - (completed ? 0 : Math.floor((now - startTime) / 1000))

    const record: SessionRecord = {
      id: crypto.randomUUID(),
      startTimestamp: new Date(startTime).toISOString(),
      endTimestamp: new Date(now).toISOString(),
      plannedDurationSeconds: params.duration,
      actualDurationSeconds: completed ? params.duration : Math.max(0, actualDuration),
      durationString: formatDuration(completed ? params.duration : Math.max(0, actualDuration)),
      mode: 'focus',  // Only focus sessions are recorded
      startType: 'manual', // Could track auto-start separately
      completed,
      noteText: params.noteState.noteText,
      tags: params.noteState.tags,
      createdAt: now,
    }

    return record
  }, [params.duration, params.noteState])

  // Save session and tags
  const saveSessionRecord = useCallback(async (completed: boolean) => {
    if (params.mode !== 'focus') return // Only save focus sessions

    const record = createSessionRecord(completed)
    await saveSession(record)

    // Save tags for autocomplete
    for (const tag of record.tags) {
      await saveTag(tag)
    }

    return record
  }, [params.mode, createSessionRecord])

  // Periodic checkpoint during active session
  useEffect(() => {
    if (!params.isRunning || params.mode !== 'focus') return
    if (!sessionStartRef.current) {
      sessionStartRef.current = Date.now()
      lastCheckpointRef.current = Date.now()
    }

    const interval = setInterval(async () => {
      const now = Date.now()
      if (now - lastCheckpointRef.current >= CHECKPOINT_INTERVAL_MS) {
        // Save checkpoint
        await saveSessionRecord(false)
        lastCheckpointRef.current = now
      }
    }, 60000) // Check every minute

    return () => clearInterval(interval)
  }, [params.isRunning, params.mode, saveSessionRecord])

  // Handle session start - reset flags
  useEffect(() => {
    if (params.isRunning && params.mode === 'focus') {
      sessionStartRef.current = Date.now()
      lastCheckpointRef.current = Date.now()
      hasCompletedRef.current = false
    }
  }, [params.isRunning, params.mode])

  // Session complete handler (called when timer hits 0)
  const handleSessionComplete = useCallback(async () => {
    if (params.mode !== 'focus' || hasCompletedRef.current) return
    hasCompletedRef.current = true

    const record = await saveSessionRecord(true)
    actions.onSessionComplete()

    return record
  }, [params.mode, saveSessionRecord, actions])

  // Session skip handler
  const handleSessionSkip = useCallback(async () => {
    if (params.mode !== 'focus') return
    hasCompletedRef.current = true

    const record = await saveSessionRecord(false)
    actions.onSessionSkip()

    return record
  }, [params.mode, saveSessionRecord, actions])

  // Session reset handler - DISCARD (don't save)
  const handleSessionReset = useCallback(() => {
    hasCompletedRef.current = true
    sessionStartRef.current = null
    lastCheckpointRef.current = 0
    actions.onSessionReset()
  }, [actions])

  // Manual save handler
  const handleManualSave = useCallback(async () => {
    if (params.mode !== 'focus' || !params.isRunning) return
    await saveSessionRecord(false)
    lastCheckpointRef.current = Date.now()
  }, [params.mode, params.isRunning, saveSessionRecord])

  return {
    handleSessionComplete,
    handleSessionSkip,
    handleSessionReset,
    handleManualSave,
  }
}
```
  </action>
  <verify>Hook exports handlers, no build errors</verify>
  <done>useSessionManager provides: handleSessionComplete, handleSessionSkip, handleSessionReset, handleManualSave</done>
</task>

<task type="auto">
  <name>Create SessionSummary modal component</name>
  <files>src/components/SessionSummary.tsx</files>
  <action>
Create post-session summary modal:

```typescript
import React from 'react'
import styled from 'styled-components'

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
`

const Modal = styled.div`
  background: white;
  padding: 2rem;
  border-radius: 12px;
  max-width: 400px;
  width: 90%;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
`

const Title = styled.h2`
  margin: 0 0 1rem;
  color: #27ae60;
  font-size: 1.5rem;
`

const Stat = styled.div`
  margin-bottom: 0.5rem;
  color: #333;
`

const Label = styled.span`
  font-weight: 600;
  color: #666;
`

const TagsContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-top: 0.5rem;
`

const Tag = styled.span`
  padding: 0.25rem 0.5rem;
  background: #e74c3c;
  color: white;
  border-radius: 12px;
  font-size: 0.8rem;
`

const NotePreview = styled.div`
  margin-top: 1rem;
  padding: 0.75rem;
  background: #f5f5f5;
  border-radius: 4px;
  font-size: 0.9rem;
  color: #666;
  max-height: 80px;
  overflow-y: auto;
`

const Button = styled.button`
  margin-top: 1.5rem;
  padding: 0.75rem 1.5rem;
  background: #27ae60;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  width: 100%;

  &:hover {
    background: #219a52;
  }
`

interface SessionSummaryProps {
  isVisible: boolean
  session: {
    durationString: string
    noteText: string
    tags: string[]
    startTimestamp: string
  } | null
  onContinue: () => void
}

export default function SessionSummary({
  isVisible,
  session,
  onContinue,
}: SessionSummaryProps) {
  if (!isVisible || !session) return null

  const formatTime = (iso: string) => {
    return new Date(iso).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
    })
  }

  return (
    <Overlay onClick={onContinue}>
      <Modal onClick={(e) => e.stopPropagation()}>
        <Title>Session Complete!</Title>
        <Stat>
          <Label>Duration:</Label> {session.durationString}
        </Stat>
        <Stat>
          <Label>Started:</Label> {formatTime(session.startTimestamp)}
        </Stat>
        {session.tags.length > 0 && (
          <Stat>
            <Label>Tags:</Label>
            <TagsContainer>
              {session.tags.map((tag, i) => (
                <Tag key={i}>{tag}</Tag>
              ))}
            </TagsContainer>
          </Stat>
        )}
        {session.noteText && (
          <NotePreview>
            {session.noteText.length > 200
              ? session.noteText.substring(0, 200) + '...'
              : session.noteText}
          </NotePreview>
        )}
        <Button onClick={onContinue}>Continue</Button>
      </Modal>
    </Overlay>
  )
}
```
  </action>
  <verify>Component renders modal with session details</verify>
  <done>SessionSummary shows modal with duration, start time, tags, note preview, and Continue button</done>
</task>

<task type="auto">
  <name>Integrate components in App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Update App.tsx to integrate NotePanel, TagInput, SessionSummary with timer:

1. Import new components and hooks:
```typescript
import NotePanel from './components/NotePanel'
import TagInput from './components/TagInput'
import SessionSummary from './components/SessionSummary'
import { useSessionNotes } from './hooks/useSessionNotes'
import { useSessionManager } from './hooks/useSessionManager'
```

2. Update state to track summary visibility and completed session:
```typescript
const [showSummary, setShowSummary] = useState(false)
const [completedSession, setCompletedSession] = useState<{
  durationString: string
  noteText: string
  tags: string[]
  startTimestamp: string
} | null>(null)
```

3. Set up session notes hook:
```typescript
const {
  noteText,
  tags,
  saveStatus,
  lastSaved,
  maxNoteLength,
  handleNoteChange,
  handleTagsChange,
  resetNotes,
} = useSessionNotes(() => {
  // Background save - no action needed, status updates automatically
})
```

4. Set up session manager:
```typescript
const noteState = { noteText, tags, lastSaved, saveStatus }

const sessionManager = useSessionManager(
  {
    mode: state.mode,
    isRunning: state.isRunning,
    duration: state.duration,
    startTime: state.startTime,
    noteState,
  },
  {
    onSessionComplete: () => {
      setShowSummary(true)
    },
    onSessionSkip: () => {
      setShowSummary(true)
    },
    onSessionReset: () => {
      resetNotes()
    },
  }
)
```

5. Determine visibility (only during Focus mode):
```typescript
const showNotePanel = state.mode === 'focus'
```

6. Update TimerControls to pass session handlers:
- Add onSessionComplete prop (for timer hitting 0 in focus mode)
- Add onSessionSkip prop (for skip button in focus mode)
- Add onSessionReset prop (for reset button - discards session)

7. Render components in App:
```tsx
<TimerControls
  isRunning={state.isRunning}
  startTime={state.startTime}
  onStart={start}
  onPause={pause}
  onResume={resume}
  onReset={reset}
  onSkip={skip}
  onSessionComplete={sessionManager.handleSessionComplete}
  onSessionSkip={sessionManager.handleSessionSkip}
  onSessionReset={sessionManager.handleSessionReset}
/>

<NotePanel
  isVisible={showNotePanel}
  noteText={noteText}
  onNoteChange={handleNoteChange}
  saveStatus={saveStatus}
  lastSaved={lastSaved}
  maxLength={maxNoteLength}
/>

<TagInput
  isVisible={showNotePanel}
  tags={tags}
  suggestions={tagSuggestions}
  onTagsChange={handleTagsChange}
/>

<SessionSummary
  isVisible={showSummary}
  session={completedSession}
  onContinue={() => {
    setShowSummary(false)
    setCompletedSession(null)
    resetNotes()
  }}
/>
```

Note: Tag suggestions should be loaded from sessionStore.getTagSuggestions(). Use useEffect to load on mount.

Per locked decisions:
- Note panel and tag input visible only during Focus mode (NOTE-01)
- Incomplete sessions discarded on reset/skip (don't call save)
- Show summary after session ends
  </action>
  <verify>Build passes, all components integrated</verify>
  <done>App.tsx integrates NotePanel, TagInput, SessionSummary, session manager hooks. Components only visible during Focus mode.</done>
</task>

<task type="auto">
  <name>Update TimerControls with session triggers</name>
  <files>src/components/TimerControls.tsx</files>
  <action>
Update TimerControls to accept session-related handlers:

1. Add new props for session handlers:
```typescript
interface TimerControlsProps {
  // existing props
  isRunning: boolean
  startTime: number | null
  onStart: () => void
  onPause: () => void
  onResume: () => void
  onReset: () => void
  onSkip: () => void
  // new session props
  onSessionComplete?: () => void
  onSessionSkip?: () => void
  onSessionReset?: () => void
  showManualSave?: boolean
  onManualSave?: () => void
}
```

2. Update button onClick handlers:
- Reset: Call onSessionReset before onReset (to discard session)
- Skip: Call onSessionSkip before onSkip (to save incomplete session)

3. Add manual save button if showManualSave is true (render in same area as note panel)

The session triggers work as follows:
- Timer hits 0 in focus mode: triggers onSessionComplete (save complete)
- User clicks Skip in focus mode: triggers onSessionSkip (save incomplete)
- User clicks Reset in focus mode: triggers onSessionReset (discard, don't save)

This requires coordinating with useTimer - the onSessionComplete should be called when timer reaches 0.
  </action>
  <verify>TimerControls accepts session handlers, no build errors</verify>
  <done>TimerControls accepts onSessionComplete, onSessionSkip, onSessionReset, onManualSave props</done>
</task>

<task type="auto">
  <name>Wire session completion in useTimer</name>
  <files>src/hooks/useTimer.ts</files>
  <action>
Update useTimer to detect session completion and trigger callbacks:

1. Add new callback props:
```typescript
interface UseTimerReturn {
  // ... existing return values
  onSessionComplete?: () => void
  onSessionSkip?: () => void
  onSessionReset?: () => void
}
```

2. In the timer completion detection (when timeRemaining reaches 0), call onSessionComplete if mode is 'focus'.

Example integration pattern:
```typescript
// In the reducer or useEffect that detects completion:
useEffect(() => {
  if (!isInitializedRef.current) return

  const wasRunning = previousTimeRef.current > 0
  const isNowComplete = state.timeRemaining === 0

  if (wasRunning && isNowComplete && state.mode === 'focus') {
    onSessionComplete?.()
  }
}, [state.timeRemaining, state.mode, onSessionComplete])
```

Note: The useTimer hook already detects completion and advances modes. The session manager will handle the actual save, and the timer just triggers the callback.

Integration with App.tsx: Pass the session handler functions from useSessionManager to useTimer.
  </action>
  <verify>useTimer can trigger session callbacks on completion</verify>
  <done>useTimer triggers onSessionComplete callback when timer hits 0 in focus mode</done>
</task>

</tasks>

<verification>
- [ ] useSessionManager hook created with all save triggers
- [ ] SessionSummary modal displays after session ends
- [ ] App.tsx integrates NotePanel, TagInput, SessionSummary
- [ ] Components only visible during Focus mode
- [ ] Reset discards session (no save)
- [ ] Skip saves incomplete session
- [ ] Periodic checkpoint saves every 5 minutes
- [ ] Manual save button works
- [ ] Summary shows session details with Continue button
</verification>

<success_criteria>
Session recording fully integrated: sessions save on timer completion, skip, periodic checkpoint, and manual save. Incomplete sessions discarded on reset. Summary modal displays after session ends. All features respect Focus-only mode requirement.
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management/02-03-SUMMARY.md`
</output>
