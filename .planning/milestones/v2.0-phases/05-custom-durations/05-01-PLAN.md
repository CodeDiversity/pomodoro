---
phase: 05-custom-durations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/timer.ts
  - src/services/persistence.ts
  - src/hooks/useTimer.ts
autonomous: true
requirements:
  - DUR-05
  - DUR-06
  - DUR-08
user_setup: []
must_haves:
  truths:
    - Custom durations are saved to IndexedDB when Save is clicked
    - Custom durations are loaded from IndexedDB on page refresh
    - Timer uses custom durations when set
    - Timer resets to new duration when changed while running
  artifacts:
    - path: src/types/timer.ts
: SET      provides_CUSTOM_DURATIONS action type
      contains: type: 'SET_CUSTOM_DURATIONS'
    - path: src/services/persistence.ts
      provides: Duration persistence (save/load)
      exports: saveSettings accepts durations, loadSettings returns durations
    - path: src/hooks/useTimer.ts
      provides: Custom duration application in reducer
      contains: case 'SET_CUSTOM_DURATIONS'
  key_links:
    - from: persistence.ts
      to: IndexedDB settings store
      via: db.put('settings', ...)
      pattern: focusDuration.*shortBreakDuration.*longBreakDuration
    - from: useTimer.ts
      to: TimerState
      via: timerReducer
      pattern: case 'SET_CUSTOM_DURATIONS'
---

<objective>
Implement data layer and timer integration for custom durations.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/05-custom-durations/05-CONTEXT.md
@.planning/phases/05-custom-durations/05-RESEARCH.md
@src/types/timer.ts
@src/services/persistence.ts
@src/hooks/useTimer.ts
</context>

<tasks>

<task type="auto">
  <name>Update AppSettings interface to include duration fields</name>
  <files>src/services/persistence.ts, src/types/timer.ts</files>
  <action>
    1. Update AppSettings interface in src/services/persistence.ts to include duration fields:
       - focusDuration: number (default 25 * 60 seconds = 1500)
       - shortBreakDuration: number (default 5 * 60 seconds = 300)
       - longBreakDuration: number (default 15 * 60 seconds = 900)

    2. Update DEFAULT_SETTINGS object with default values in seconds:
       - focusDuration: 1500 (25 minutes)
       - shortBreakDuration: 300 (5 minutes)
       - longBreakDuration: 900 (15 minutes)

    3. Update saveSettings function to accept full AppSettings with duration fields and persist all duration values to IndexedDB "settings" store (not sessions store)

    4. Update loadSettings function to return duration values from IndexedDB, falling back to defaults if not set
  </action>
  <verify>TypeScript compiles with no errors: npx tsc --noEmit</verify>
  <done>AppSettings interface includes focusDuration: number (default 25), shortBreakDuration: number (default 5), longBreakDuration: number (default 15) - all in minutes</done>
</task>

<task type="auto">
  <name>Update persistence layer for durations</name>
  <files>src/services/persistence.ts</files>
  <action>
    1. Ensure saveSettings function writes duration values to IndexedDB using db.put('settings', ...) with the settings store

    2. Ensure loadSettings function reads duration values from the same 'settings' store in IndexedDB

    3. Return full settings object including all three duration values
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit</verify>
  <done>saveSettings saves duration values to IndexedDB, loadSettings retrieves duration values from IndexedDB, uses "settings" store (not sessions store)</done>
</task>

<task type="auto">
  <name>Add SET_CUSTOM_DURATIONS reducer action</name>
  <files>src/types/timer.ts, src/hooks/useTimer.ts</files>
  <action>
    1. Add to TimerAction type union in src/types/timer.ts:
       { type: 'SET_CUSTOM_DURATIONS'; payload: { focus: number; shortBreak: number; longBreak: number } }

    2. Add reducer case in src/hooks/useTimer.ts for SET_CUSTOM_DURATIONS:
       - Extract custom durations from action.payload
       - Update state.duration[state.mode] to new value
       - When timer is idle: update timer display to new duration
       - When timer is running: reset timer to new duration (per DUR-08)
       - Reset isRunning to false, startTime to null, pausedTimeRemaining to null

    3. Add setCustomDurations callback that dispatches SET_CUSTOM_DURATIONS action

    4. Export setCustomDurations in the return object

    5. Fix load order in useEffect: load settings first, then load timer state, then apply custom durations if they exist
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit</verify>
  <done>Action accepts focusDuration, shortBreakDuration, longBreakDuration; when timer is idle updates timer display to new duration; when timer is running resets timer to new duration (DUR-08); timer state reflects new duration values</done>
</task>

</tasks>

<verification>
- DUR-05: Validation happens in Settings UI (plan 02)
- DUR-06: Custom durations persist via IndexedDB, loaded on page refresh
- DUR-08: Timer resets when custom durations applied while running
</verification>

<success_criteria>
- AppSettings interface includes duration fields
- saveSettings persists durations to IndexedDB
- loadSettings returns durations from IndexedDB
- SET_CUSTOM_DURATIONS action type exists
- Timer reducer handles SET_CUSTOM_DURATIONS (resets timer)
- Custom durations are loaded on app initialization
</success_criteria>

<output>
After completion, create .planning/phases/05-custom-durations/05-01-SUMMARY.md
</output>
