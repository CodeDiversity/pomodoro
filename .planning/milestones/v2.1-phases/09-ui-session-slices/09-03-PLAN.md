---
phase: 09-ui-session-slices
plan: 03
type: execute
wave: 2
depends_on:
  - 09-01
  - 09-02
files_modified:
  - src/app/store.ts
  - src/hooks/useSessionNotes.ts
  - src/App.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "useSessionNotes hook maintains same API after Redux refactor"
    - "Components using useSessionNotes require no changes"
    - "Session state loads from IndexedDB on app start"
  artifacts:
    - path: "src/hooks/useSessionNotes.ts"
      provides: "Session notes hook using Redux while maintaining API"
      contains: "useAppDispatch"
    - path: "src/App.tsx"
      provides: "App using Redux for session notes via useSessionNotes"
      contains: "useSessionNotes"
    - path: "src/app/store.ts"
      provides: "Store with session slice and middleware"
      contains: "session: sessionReducer"
  key_links:
    - from: "src/hooks/useSessionNotes.ts"
      to: "src/features/session/sessionSlice.ts"
      via: "dispatch actions"
      pattern: "dispatch.*setNoteText"
---

<objective>
Refactor useSessionNotes hook to use Redux while maintaining existing API. Wire session state loading on app start.

Purpose: Maintain hook API compatibility so components using useSessionNotes require no changes. This is the key requirement from REDUX-04.

Output: Updated useSessionNotes.ts, updated store.ts, App.tsx with session loading
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/09-ui-session-slices/09-RESEARCH.md
@src/hooks/useSessionNotes.ts
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Update store with session slice and middleware</name>
  <files>src/app/store.ts</files>
  <action>
Update src/app/store.ts to include session slice:

1. Import sessionReducer from '../features/session/sessionSlice'
2. Import sessionPersistenceMiddleware from '../features/session/sessionMiddleware'
3. Add session: sessionReducer to the reducer configuration
4. Add .prepend(sessionPersistenceMiddleware) to the middleware chain

Final middleware chain should be:
```typescript
middleware: (getDefaultMiddleware) =>
  getDefaultMiddleware({
    serializableCheck: {
      ignoredActions: ['timer/start', 'timer/resume'],
    },
  })
    .prepend(timerPersistenceMiddleware)
    .prepend(sessionPersistenceMiddleware)
```
  </action>
  <verify>TypeScript compiles and store has session reducer + middleware</verify>
  <done>Store configured with session slice and middleware</done>
</task>

<task type="auto">
  <name>Refactor useSessionNotes to use Redux</name>
  <files>src/hooks/useSessionNotes.ts</files>
  <action>
Refactor src/hooks/useSessionNotes.ts to use Redux while maintaining the same API:

1. Import useAppDispatch and useAppSelector from '../app/hooks'
2. Import { setNoteText, setTags, resetSession, markSaved, loadSession } from '../features/session/sessionSlice'
3. Import { loadSessionState } from '../services/persistence'
4. Remove useState, useRef imports (no longer needed)
5. Remove local state - now use useAppSelector
6. Keep MAX_NOTE_LENGTH = 2000 constant

7. Modify the hook function:
   ```typescript
   export function useSessionNotes(onSave?: (note: string, tags: string[]) => void) {
     const dispatch = useAppDispatch()
     const { noteText, tags, saveStatus, lastSaved } = useAppSelector(state => state.session)

     // Load session state from IndexedDB on mount
     useEffect(() => {
       loadSessionState().then((savedState) => {
         if (savedState) {
           dispatch(loadSession({
             noteText: savedState.noteText,
             tags: savedState.tags,
             saveStatus: 'idle',
             lastSaved: savedState.lastSaved,
           }))
         }
       })
     }, [dispatch])

     const handleNoteChange = useCallback((text: string) => {
       if (text.length <= MAX_NOTE_LENGTH) {
         dispatch(setNoteText(text))
         onSave?.(text, tags)
       }
     }, [dispatch, tags, onSave])

     const handleTagsChange = useCallback((newTags: string[]) => {
       dispatch(setTags(newTags))
       onSave?.(noteText, newTags)
     }, [dispatch, noteText, onSave])

     const resetNotes = useCallback(() => {
       dispatch(resetSession())
     }, [dispatch])

     return {
       noteText,
       tags,
       saveStatus,
       lastSaved,
       maxNoteLength: MAX_NOTE_LENGTH,
       handleNoteChange,
       handleTagsChange,
       resetNotes,
     }
   }
   ```

Key: The return object MUST match original API exactly - same keys, same types.
  </action>
  <verify>TypeScript compiles, hook returns same API shape, App.tsx works unchanged</verify>
  <done>useSessionNotes refactored to use Redux while maintaining API</done>
</task>

<task type="auto">
  <name>Verify App.tsx works with session Redux</name>
  <files>src/App.tsx</files>
  <action>
Verify App.tsx works with session Redux - it should work with minimal changes:

1. Ensure useSessionNotes import is still present
2. The useSessionNotes() call should work unchanged because the API is preserved
3. Check that NotePanel receives the correct props from useSessionNotes
4. Ensure resetNotes() is still called correctly in session completion flow

If any adjustments needed, make minimal changes to ensure compatibility.
  </action>
  <verify>App builds without errors, session notes work in UI</verify>
  <done>App.tsx works correctly with session Redux</done>
</task>

</tasks>

<verification>
- [ ] store.ts has session reducer and middleware
- [ ] useSessionNotes hook uses Redux (useAppDispatch, useAppSelector)
- [ ] useSessionNotes returns same API shape as before
- [ ] App.tsx works with useSessionNotes unchanged
- [ ] TypeScript compiles without errors
- [ ] Session state persists across page refresh
</verification>

<success_criteria>
1. useSessionNotes hook maintains same API - components require no changes
2. Session notes and tags save to Redux with debounced persistence (500ms)
3. Session state loads from IndexedDB on app start
4. All success criteria from Phase 9 met
</success_criteria>

<output>
After completion, create `.planning/phases/09-ui-session-slices/09-03-SUMMARY.md`
</output>
