---
phase: 09-ui-session-slices
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/features/session/sessionSlice.ts
  - src/features/session/sessionMiddleware.ts
  - src/services/persistence.ts
  - src/services/db.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Session notes and tags state managed in Redux"
    - "Debounced persistence (500ms) for session notes"
    - "Session state survives page refresh"
  artifacts:
    - path: "src/features/session/sessionSlice.ts"
      provides: "Session state slice with noteText, tags, saveStatus"
      exports: ["setNoteText", "setTags", "markSaved", "resetSession", "loadSession"]
    - path: "src/features/session/sessionMiddleware.ts"
      provides: "Debounced persistence middleware (500ms)"
      contains: "DEBOUNCE_MS.*500"
    - path: "src/services/persistence.ts"
      provides: "Session state persistence functions"
      exports: ["saveSessionState", "loadSessionState"]
  key_links:
    - from: "src/features/session/sessionMiddleware.ts"
      to: "src/services/persistence.ts"
      via: "import"
      pattern: "saveSessionState"
---

<objective>
Create Session slice with debounced persistence middleware (500ms).

Purpose: Migrate session notes state to Redux while maintaining the same 500ms debounce timing from useSessionNotes. Session state should persist to IndexedDB.

Output: sessionSlice.ts, sessionMiddleware.ts, updated persistence.ts, updated db.ts
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/09-ui-session-slices/09-RESEARCH.md
@src/features/timer/timerMiddleware.ts
@src/services/persistence.ts
@src/services/db.ts
</context>

<tasks>

<task type="auto">
  <name>Create session slice</name>
  <files>src/features/session/sessionSlice.ts</files>
  <action>
Create src/features/session/sessionSlice.ts:

1. Define SessionState interface with:
   - noteText: string
   - tags: string[]
   - saveStatus: 'idle' | 'saving' | 'saved'
   - lastSaved: number | null
2. Create initialState: noteText='', tags=[], saveStatus='idle', lastSaved=null
3. Create reducers using createSlice:
   - setNoteText(state, action: PayloadAction<string>) - sets noteText, sets saveStatus='saving'
   - setTags(state, action: PayloadAction<string[]>) - sets tags, sets saveStatus='saving'
   - setSaveStatus(state, action: PayloadAction<'idle'|'saving'|'saved'>) - direct status set
   - markSaved(state) - sets saveStatus='saved', lastSaved=Date.now()
   - resetSession(state) - resets all to initial
   - loadSession(state, action: PayloadAction<SessionState>) - replaces state (for hydration)
4. Export all actions and the reducer

Match the 500ms debounce timing from current useSessionNotes implementation.
  </action>
  <verify>File exists at src/features/session/sessionSlice.ts and exports all required actions</verify>
  <done>Session slice created with noteText, tags, saveStatus, lastSaved state and actions</done>
</task>

<task type="auto">
  <name>Add session state to IndexedDB schema</name>
  <files>src/services/db.ts</files>
  <action>
Update src/services/db.ts to add sessionState store:

1. Add SessionStateData interface to PomodoroDBSchema (or as separate type):
   ```typescript
   interface SessionStateData {
     noteText: string
     tags: string[]
     lastSaved: number | null
     version: number
   }
   ```

2. Add sessionState to the DBSchema:
   ```typescript
   interface PomodoroDBSchema extends DBSchema {
     // existing stores...
     sessionState: {
       key: string  // use 'current' as key
       value: SessionStateData
     }
   }
   ```

3. Add upgrade code in initDB for version 3 (bump DB_VERSION to 3):
   ```typescript
   if (oldVersion < 3) {
     if (!db.objectStoreNames.contains('sessionState')) {
       db.createObjectStore('sessionState', { keyPath: 'id' })
     }
   }
   ```

4. Export the new interface if needed.
  </action>
  <verify>TypeScript compiles and DB schema includes sessionState store</verify>
  <done>IndexedDB schema updated with sessionState store</done>
</task>

<task type="auto">
  <name>Add session persistence functions</name>
  <files>src/services/persistence.ts</files>
  <action>
Update src/services/persistence.ts to add session state functions:

1. Add SessionStateData import (from db.ts or define inline)
2. Add SESSION_STATE_KEY = 'current' constant
3. Add saveSessionState function:
   ```typescript
   export async function saveSessionState(state: {
     noteText: string
     tags: string[]
     lastSaved?: number
   }): Promise<void> {
     try {
       if (!isIndexedDBAvailable()) return
       const db = await initDB()
       await db.put('sessionState', {
         id: SESSION_STATE_KEY,
         noteText: state.noteText,
         tags: state.tags,
         lastSaved: state.lastSaved ?? Date.now(),
         version: 1,
       })
     } catch (error) {
       console.error('Failed to save session state:', error)
     }
   }
   ```

4. Add loadSessionState function:
   ```typescript
   export async function loadSessionState(): Promise<{
     noteText: string
     tags: string[]
     lastSaved: number | null
   } | null> {
     try {
       if (!isIndexedDBAvailable()) return null
       const db = await initDB()
       const stored = await db.get('sessionState', SESSION_STATE_KEY)
       if (!stored) return null
       return {
         noteText: stored.noteText || '',
         tags: stored.tags || [],
         lastSaved: stored.lastSaved || null,
       }
     } catch (error) {
       console.error('Failed to load session state:', error)
       return null
     }
   }
   ```
  </action>
  <verify>Functions exist and TypeScript compiles without errors</verify>
  <done>Persistence functions added for session state</done>
</task>

<task type="auto">
  <name>Create session persistence middleware</name>
  <files>src/features/session/sessionMiddleware.ts</files>
  <action>
Create src/features/session/sessionMiddleware.ts:

1. Import Middleware, isAction from '@reduxjs/toolkit'
2. Import type RootState from '../../app/store'
3. Import saveSessionState from '../../services/persistence'
4. Create let saveTimeout: ReturnType<typeof setTimeout> | null = null
5. Define DEBOUNCE_MS = 500 (matching current useSessionNotes)
6. Create middleware:
   ```typescript
   export const sessionPersistenceMiddleware: Middleware = (store) => (next) => (action) => {
     const result = next(action)

     if (!isAction(action) || !action.type.startsWith('session/')) {
       return result
     }

     // Only persist on note/tags changes, not status updates
     const relevantActions = ['session/setNoteText', 'session/setTags', 'session/resetSession']
     if (!relevantActions.includes(action.type)) {
       return result
     }

     const state = store.getState() as RootState
     const sessionState = state.session

     // Clear any pending save
     if (saveTimeout) {
       clearTimeout(saveTimeout)
     }

     // Debounce the save (500ms)
     saveTimeout = setTimeout(async () => {
       try {
         await saveSessionState({
           noteText: sessionState.noteText,
           tags: sessionState.tags,
         })
         store.dispatch({ type: 'session/markSaved' })
       } catch (error) {
         console.error('Failed to persist session state:', error)
       }
     }, DEBOUNCE_MS)

     return result
   }
   ```

7. Export the middleware

Important: Dispatch markSaved AFTER successful save to update saveStatus.
  </action>
  <verify>File exists at src/features/session/sessionMiddleware.ts with 500ms debounce</verify>
  <done>Session persistence middleware created with 500ms debounce</done>
</task>

</tasks>

<verification>
- [ ] sessionSlice.ts created at src/features/session/
- [ ] db.ts updated with sessionState store (DB_VERSION bump to 3)
- [ ] persistence.ts has saveSessionState and loadSessionState functions
- [ ] sessionMiddleware.ts created with 500ms debounce
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
1. Session notes and tags state managed in Redux
2. Debounced persistence (500ms) matches current useSessionNotes timing
3. Session state persists to IndexedDB and survives page refresh
</success_criteria>

<output>
After completion, create `.planning/phases/09-ui-session-slices/09-02-SUMMARY.md`
</output>
